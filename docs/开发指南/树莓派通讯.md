解释待更新

=== "Rb_pie.c"

    ```c
    Rb_Pie_struct Rb_Pie;
    uint8_t Rb_Pie_TxBuf[10];
    
    void Rb_Pie_Send_Mode(Rb_Pie_struct *Data) {
    
        Rb_Pie_TxBuf[0] = Data->frame_head;
        Rb_Pie_TxBuf[1] = Data->Rb_Pie_Set_Mode_ONE;
        Rb_Pie_TxBuf[2] = Data->Rb_Pie_Set_Mode_TWO;
        Rb_Pie_TxBuf[3] = 0x5B;
        HAL_UART_Transmit(&RB_PIEUART, Rb_Pie_TxBuf, 4, 10);
        HAL_Delay(1);
    }
    
    void Rb_Pie_Init(Rb_Pie_struct *Data) {
    
        for (uint16_t i = 0; i < RB_PIE_RXBUFFER_LEN; i++) {
            Data->RxBuffer[i] = 0;
        }
        Data->frame_head = 0x66;
        Data->Rx_flag = 0;
        Data->Rx_len = 0;
        Data->Matter_Check = FAILRECEIVE;
        Data->Rb_Pie_Check = FAILRECEIVE;
        Data->Matter_Color_Check = FAILRECEIVE;
    }
    
    void Rb_Pie_Process(Rb_Pie_struct *Data) {
        /* 判断数据格式是否正确 */
        if (Data->RxBuffer[0] == Data->frame_head && Data->RxBuffer[8] == 0x5b) {
            if (Data->Rb_Pie_Set_Mode_ONE == Data->RxBuffer[1]) {
                Data->Matter[0] = Data->RxBuffer[2];
                Data->Matter[1] = Data->RxBuffer[3];
                Data->Matter[2] = Data->RxBuffer[4];
                Data->Matter[3] = Data->RxBuffer[5];
                Data->Matter[4] = Data->RxBuffer[6];
                Data->Matter[5] = Data->RxBuffer[7];
                Data->Matter_Check = SUCCESSRECEIVE;
            }
        }
    
        if (Data->RxBuffer[0] == Data->frame_head && Data->RxBuffer[9] == 0x5b) {
            if (Data->Rb_Pie_Set_Mode_ONE == Data->RxBuffer[1] && Data->RxBuffer[2] == RB_PIE_MODE_ADJUST) {
                //模式
                Data->Rb_Pie_Mode = Data->RxBuffer[1];
    
                //X坐标
                if (Data->RxBuffer[3] == 0x00) {
                    Data->Rb_Pie_X_Cd = -(float) ((Data->RxBuffer[5] << 8 | Data->RxBuffer[4]) / 100);
                } else if (Data->RxBuffer[3] == 0x01) {
                    Data->Rb_Pie_X_Cd = (float) ((Data->RxBuffer[5] << 8 | Data->RxBuffer[4]) / 100);
                }
    
                //Y坐标
                if (Data->RxBuffer[6] == 0x00) {
                    Data->Rb_Pie_Y_Cd = -(float) ((Data->RxBuffer[8] << 8 | Data->RxBuffer[7]) / 100);
                } else if (Data->RxBuffer[6] == 0x01) {
                    Data->Rb_Pie_Y_Cd = (float) ((Data->RxBuffer[8] << 8 | Data->RxBuffer[7]) / 100);
                }
    
                /* 如果坐标全高 或 模式为空 则数据无效 */
                if ((Data->Rb_Pie_X_Cd == 0xfff && Data->Rb_Pie_Y_Cd == 0xfff) || Data->Rb_Pie_Color == 0xC4)
                //|| (Data->Rb_Pie_Mode == RB_PIE_MODE_STOP))
                {
                    Data->Rb_Pie_Renew = FAILRECEIVE;
                    Data->Rb_Pie_X_Cd = 0;
                    Data->Rb_Pie_Y_Cd = 0;
                    Data->Rb_Pie_Color = 0XC4;
                }
                /* 数据有效 */
                else {
                    float norm_angle = HWT101_Struct.CurrentAngle;
                    Data->Rb_Pie_X = Data->Rb_Pie_X_Cd * cosf(norm_angle * M_PI / 180.0f) - Data->Rb_Pie_Y_Cd * sinf(norm_angle * M_PI / 180.0f);
                    Data->Rb_Pie_Y = Data->Rb_Pie_X_Cd * sinf(norm_angle * M_PI / 180.0f) + Data->Rb_Pie_Y_Cd * cosf(norm_angle * M_PI / 180.0f);
                    Data->Rb_Pie_X_Cd = 0;
                    Data->Rb_Pie_Y_Cd = 0;
                    Data->Rb_Pie_Renew = SUCCESSRECEIVE;
                }
            }
        }
    
        if (Data->RxBuffer[0] == Data->frame_head && Data->RxBuffer[2] == 0x5b) {
            switch (Data->RxBuffer[1]) {
                case RB_PIE_MODE_STOP:
                    System_State.Body_POS_Mode = BODY_POS_RESET;
                    Data->Rb_Pie_Set_Mode_TWO = RB_PIE_MODE_SCAN;
                    break;
                default: ;
            }
        }
    
        if (Data->RxBuffer[0] == Data->frame_head &&Data->RxBuffer[3] == 0x5b) {
    
            if (Data->RxBuffer[1] == RB_PIE_MODE_RING && Data->RxBuffer[2] == RB_PIE_MODE_JUESAI) {
    
                Data->Matter_six_JUESAI_Check = SUCCESSRECEIVE;
            }
        }
    
        if (Data->RxBuffer[0] == Data->frame_head && Data->RxBuffer[7] == 0x5b) {
    
            if (Data->Rb_Pie_Set_Mode_ONE == Data->RxBuffer[1] && Data->Rb_Pie_Set_Mode_TWO == RB_PIE_MODE_SCAN) {
                Data->Matter_Color_Check = SUCCESSRECEIVE;
    
                Data->Matter_Mode = 0;
                Data->Matter_Mode = Data->RxBuffer[2];
    
                Data->Matter_Color = 0;
                switch (Data->RxBuffer[3]) {
    
                    case RB_PIE_COLOR_RED:
                        Data->Matter_Color = MATTER_RED;
                        break;
    
                    case RB_PIE_COLOR_GREEN:
                        Data->Matter_Color = MATTER_GREEN;
                        break;
    
                    case RB_PIE_COLOR_BLUE:
                        Data->Matter_Color = MATTER_BLUE;
                        break;
    
                    default: ;
                }
                Data->Matter_Number = 0;
                Data->Matter_Number = Data->RxBuffer[4];
                Data->Matter_Color2 = 0;
                switch (Data->RxBuffer[5]) {
    
                    case RB_PIE_COLOR_RED:
                        Data->Matter_Color2 = MATTER_RED;
                        break;
    
                    case RB_PIE_COLOR_GREEN:
                        Data->Matter_Color2 = MATTER_GREEN;
                        break;
    
                    case RB_PIE_COLOR_BLUE:
                        Data->Matter_Color2 = MATTER_BLUE;
                        break;
    
                    default: ;
                }
                Data->Matter_Number2 = 0;
                Data->Matter_Number2 = Data->RxBuffer[6];
            }
        }
        /* 清空数组 */
        for (int i = 0; i < RB_PIE_RXBUFFER_LEN; i++) Data->RxBuffer[i] = 0;
    }
    
    void Rb_Pie_IRQ(void) {
    
        if (__HAL_UART_GET_FLAG(&RB_PIEUART, UART_FLAG_IDLE) != RESET) {
    
            __HAL_UART_CLEAR_IDLEFLAG(&RB_PIEUART);
            HAL_UART_DMAStop(&RB_PIEUART); //关闭DMA，防止冲突
            Rb_Pie.Rx_len = RB_PIE_RXBUFFER_LEN; //获得一共传输的个数
            Rb_Pie_Process(&Rb_Pie);
            HAL_UART_Receive_DMA(&RB_PIEUART, Rb_Pie.RxBuffer,RB_PIE_RXBUFFER_LEN); //重新开始接收DMA
        }
    }
    ```

=== "Rb_pie.h"

    ```c
    #ifndef INC_RB_PIE_H_
    #define INC_RB_PIE_H_
    
    #include "main.h"
    
    
    #define RB_PIE_RXBUFFER_LEN 10
    #define RB_PIEUART	huart3
    #define RB_PIEDMAUART hdma_usart3_rx
    
    #define RB_PIE_COLOR_RED   0xC1	//接收红色
    #define RB_PIE_COLOR_GREEN 0xC2	//接收绿色
    #define RB_PIE_COLOR_BLUE  0xC3	//接收蓝色
    
    #define RB_PIE_MODE_ZERO 0x00
    
    #define RB_PIE_MODE_CO			 0xE1	//色块模式
    #define RB_PIE_MODE_RING		 0xE2	//色环模式
    #define RB_PIE_MODE_QR			 0xE3	//QR扫码模式
    #define RB_PIE_MODE_RING_TWO	 0xE4	//色环模式2
    #define RB_PIE_MODE_STOP		 0xE5	//停止模式
    
    #define RB_PIE_MODE_ADJUST		 0xD1	//校准
    #define RB_PIE_MODE_SCAN		 0xD2	//识别
    #define RB_PIE_MODE_JUESAI		 0xD3	//识别2
    
    typedef struct
    {
            __IO uint8_t Rx_flag;
            __IO uint8_t Rx_len;
            __IO uint8_t frame_head;					//帧头
    
            __IO uint8_t Rb_Pie_Mode;					//模式
            __IO uint8_t Rb_Pie_Set_Mode_ONE;			//模式一
            __IO uint8_t Rb_Pie_Color;					//颜色
            __IO uint8_t Rb_Pie_Set_Mode_TWO;			//模式二
            __IO float Rb_Pie_X_Cd;					//X坐标
            __IO float Rb_Pie_X;					//X全局坐标
            __IO float Rb_Pie_Y_Cd;					//Y坐标
            __IO float Rb_Pie_Y;					//Y全局坐标
            uint16_t Rb_Pie_Check;
    
            __IO uint16_t Matter[6];
            __IO uint16_t Matter_Mode;
            __IO uint16_t Matter_Color;
            __IO uint16_t Matter_Color2;
            __IO uint16_t Matter_Number;
            __IO uint16_t Matter_Number2;
            uint16_t Matter_Check;
            uint16_t Matter_Color_Check;
            uint16_t Matter_E5_Check;
            uint16_t Matter_six_JUESAI_Check;
    
            __IO uint16_t Rb_Pie_Renew;					//数据更新标志
    
            uint8_t RxBuffer[RB_PIE_RXBUFFER_LEN];		//接收缓冲
    }Rb_Pie_struct;
    
    extern Rb_Pie_struct Rb_Pie;
    void Rb_Pie_Send_Mode(Rb_Pie_struct * Data);
    void Rb_Pie_Init(Rb_Pie_struct * Data); 	//树莓派初始化
    void Rb_Pie_IRQ(void);						//树莓派读取
    
    #endif /* INC_RB_PIE_H_ */
    ```